[{"title":"解构赋值","url":"/2019/01/24/解构赋值/","content":"#变量的解构赋值\n##目录\n1.数组的解构赋值\n2.对象的解构赋值\n3.字符串的解构赋值\n4.数值和布尔值的解构赋值\n5.函数参数的解构赋值\n6.圆括号问题\n7.用途\n\n###数组的解构赋值\n1. 定义\n&emsp; &emsp;Es6中允许按照一定模式,兄数组和对象中提取值，对变量进行赋值,这种称为解构\n    ````\n    let [a,b,c] = [1,2,3]\n\n\n    let [foo, [\n        [bar], roo\n    ], baz] = [1, [\n        [2], 3\n    ], 9]\n\n    //例子2\n    let [, , thrid] = ['foo', 'zaa', 'baz']\n\n    //例子3\n    let [x, , y] = [1, 2, 3]\n\n    //例子4\n    let [head, ...tail] = [1, 2, 3, 4]\n\n\n    //例子5\n    let [...taile] = [1, 2, 3, 4]\n    ````\n\n2. 不完全解构但可以成功\n\n    ````\n    let [a,b] = [1,3,4]\n\n    let [a,[b,c],d] = [1,[2,3],5]\n    ````\n\n###注意地方  (不完全解构但失败)\n&emsp; &emsp; 解构要求是左右两边的数据类型都一样,如果有一方不一样则不会成功\n    ````\n    let [bar,foo] = [1]\n    ````\n\n3. set方法使用数组的解构赋值\n\n    ````\n    let [u, i, o] = new Set(['a', 'b', 'c'])\n    ````\n\n4. Generator函数使用解构赋值\n\n    ````\n    //例子8  不懂的地方\n    function* fibs() {\n        let a = 0;\n        let b = 1;\n        while (true) {\n            yield a; //0 1 1 2 3 5 \n            [a, b] = [b, a + b]; // \n        }\n    }\n\n    let [first, second, third, fourth, fifth, sixth] = fibs();\n    sexth //5\n\n    ````\n\n5. 解构赋值中的默认值的处理\n  1.在es6中使用校验是 '===' 严格相等,即严格等于undefined才能调用默认值的调用\n\n    ````\n        let [foow = true] = []\n        foow//true\n        let [a, s = 'b'] = ['a']\n        a //a\n        s//b\n        let [f, t = 'b'] = ['e', undefined]\n        f//e\n        t//b\n    ````\n\n    ####注意的地方\n    1. 如果默认值是一个表达式,那么这个表达式是惰性求值,即只有在用到的时候,才会求值\n\n    ````\n\n   //例子10  没调用函数\n        function fddd() {\n            console.log('aaaa');\n        }\n        let [xrrr = fddd()] = [null]\n\n    //例子11  调用函数\n        function fddd() {\n            console.log('aaaa');\n        }\n        let [xrrr = fddd()] = [undefined]\n\n  ````\n\n  2. 默认值可以引用解构赋值的其他变量,但该变量必须已经声明.必须是已经定义过的\n    ````\n        let [x=1,y=1] = []\n        let [x=1,y=x] = [2]   x=2,y=2\n        let [x=y,y=1] = []   //报错,没有提前定义\n\n    ````\n\n\n\n\n   \n###对象的解构赋值\n1. 定义\n&emsp;&emsp;同样解构赋值也能为对象来进行服务。\n&emsp;&emsp;对象的解构与数组有一个重要的不同,数组的元素是按次序排列的,变量的取值由它的位置决定;必须变量与属性名相同来进行获取\n2. 不同的写法\n  &emsp;2.1 定义写法\n    ````\n    //例子1\n    let {foo,boo} = {'foo':'aaa','boo':'222'}\n        //foo  aaa\n        //boo  222\n\n        //例子2\n    let {fooa,bara} = {'bara':'aaa','fooa':'bbb'}\n    //fooa aaa\n    //bara bbb\n    \n    //例子3\n    let {fooe,bare,baza} = {'baex':1,'fooe':2,'bare':3}\n        //console.log(fooe,bare,baza);\n        //2 3 undefined\n\n        //例子4\n        let obj = {'first':'hellow','second':'world'}\n        let {first,second} = obj\n        //first hellow\n        //second world\n\n\n        //例子5 (这种写法是一种变相的赋值)\n            let {frr:baree} = {frr:222,bre:'fff'}\n            //console.log(baree);\n    ````\n3. 如果变量提前声明,那么一定要用（）来进行包起来,因为解析器解析的时候会字段加上()\n    ````\n    let foo;\n    ({foo} = {foo:1})\n    let baredt;\n    ({baredt} - {baredt:2})\n    ````\n4. 因为数组是特殊的对象,所以可以和数组进行解构赋值\n\n    ````\n    let arr = [1, 2, 3]; \n    let {0 : firstee, [arr.length - 1] : lastee} = arr;\n    console.log(firstee,lastee,arr.length-1); //  1,2,3\n    let {'0':fffd,'1':fff,'2':ffff} = [1,2,3]  //1,2,3\n    ````\n\n"},{"title":"es6简介","url":"/2019/01/24/es6简介/","content":"## 转码器\n### babel转码器 \n\n1. 简介\n&emsp;&emsp;Babel是一个广泛使用d额ES6转码器,可以将ES6代码转化为ES5,从而让现在的环境可以支持\n2. 配置文件为.babelrc\n&emsp;&emsp;放置在项目的根目录下面,使用的第一步就是要去配置这个文件\n&emsp;&emsp;配置格式如下\n   ````\n   {  \"presets\": [],\n   \"plugins\": [] }\n   ````\npresets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。\n      ````\n        #最新转码规则 \n        $ npm install --save-dev babel-preset-latest\n        # react 转码规则 \n        $ npm install --save-dev babel-preset-react\n        # 不同阶段语法提案的转码规则（共有4个阶段），选装一个 \n        $ npm install --save-dev babel-preset-stage-0 $ npm install --save-dev babel-preset-stage-1 $ npm install --save-dev babel-preset-stage-2 $ npm install --save-dev babel-preset-stage-3\n        然后，将这些规则加入.babelrc。\n        {    \"presets\":\n         [      \"latest\",      \"react\",      \"stage-2\"    ],    \n         \"plugins\": []  \n         }\n        注意，以下所有 Babe l工具和模块的使用，都必须先写好.babelrc。\n      ````\n3. 命令行转码 (babel-cli)\n        ````\n        $ npm install --global babel-cli\n        ````\n    3.1 用法\n        ````\n        # 转码结果输出到标准输出 \n        $ babel example.js\n        # 转码结果写入一个文件 # --out-file 或 -o 参数指定输出文件 \n        $ babel example.js --out-file compiled.js \n        # 或者 \n        $ babel example.js -o compiled.js\n        # 整个目录转码 # --out-dir 或 -d 参数指定输出目录 \n        $ babel src --out-dir lib \n        # 或者 \n        $ babel src -d lib\n        # -s 参数生成source map文件 \n        $ babel src -d lib -s\n        ````\n\n   3.2 babel-node\n      babel-node 命令可以直接运行es6脚本.将上面的代码放入脚本文件es6.js,然后直接运行\n       ````\n       $ babel-node es6.js\n       ````\n\n### Traceur转码器\n 1. 使用方法\n   ````\n   <script src=\"https://google.github.io/traceur-compiler/bin/traceur.js\">\n   </script>\n   <script src=\"https://google.github.io/traceur-compiler/bin/BrowserSystem.js\">\n   </script> \n   <script src=\"https://google.github.io/traceur-compiler/src/bootstrap.js\">\n   </script> \n   <script type=\"module\">import './Greeter.js'</script>\n   ````\n2. 命令行转码\n   ```` \n   $ npm install -g traceu\n   $ traceur <文件夹名字> Calc constructor \n   $ $ traceur --script <文件夹名字> --out <文件夹名字> --experimental\n   #--script选项表示指定输入文件,--out表示指定输出文件\n   ````\n### 变量改变\n````\n1. let  {{{{}}}}\n变量声明,和var一样,但是有作用域的限制,只有在规定的代码块内才有用,不存在变量提升,不允许在函数变量内重复声明 \n2. const \n常量声明,不能进行重复声明\n3. do表达式\n现在是有一个提案,使得块级作用域变为表达式,给块级作用域前面加上do,使他变为do表达式\nlet x = do{\n   let t = f()\n   t = t + 1\n}\n````\n### ES6变量声明的六种方法\n1.let\n2.const\n3.class\n4.import\n5.var\n6.function\n\n### 顶层对象的属性  \n1. js中的顶层对象是     window \n&emsp; &emsp;es6逐渐将顶层创建对象和全部变量分开了\n&emsp; &emsp;window.a (顶层变量)\n&emsp; &emsp;es6则除了var 和 function能创建顶层变量,其余的只能创建块级元素变量\n2. Node中的顶层对象是   global\n&emsp; &emsp;因为顶层对象在不同的环境中不一样,所以每个环境中叫的名字也不一样.\n浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。 Node 里面，顶层对象是global，但其他环境都不支持。\n   ````\n      //获取顶层对象\n      (typeof window !== 'undefined' ? \n      window :(typeof process === 'object' && \n               typeof require === 'function' &&\n               typeof global === 'object')\n               ? global : this)\n\n      //方法二获取顶层对象\n      var getGlobal = function (){\n      if(typeof self !== 'undefined'){return self}\n      if(typeof window !== 'undefind'){return window}\n      if(typeof global !== 'undefind'){return global}\n      throw new Error('unable to locate global object')\n   ````   \n3.现在有一个提案,是统一在一个地方防止一个global找到一个垫片库,system.global \n````\n//commonJs\nrequire('system.global/shim')()\n//es6模块的写法\nimport shim from 'system.global/shim';shim()\n//ComminJs的写法\nvar global = require('system.global')()\n//ES6模块的写法\nimport getGlobal from 'system.global';\nconst global = getGlobal()\n````"},{"title":"Promise实现原理","url":"/2019/01/16/Promise实现原理/","content":"## 基本结构\n1. Promise 基本结构\n     ```\n     new Promise(function(resolve, reject) {\n        setTimeout(() => {\n            resolve('FULLWS')\n\n        })\n     })\n     ```\n2. 判断一个变量是否为函数的方法\n ```\n  const isFunction = variabale => typeof variabale === 'function'\n ```\n3. es6新增一个class申明现象,所以用语法申明一个写法\n```\n  class MyPromise{\n      constructor(handle){\n          throw new Error('MyPromise must accept a function as a parameter')\n      }\n  }\n```\n\n## Promise 状态和值\n\nPromise 对象存在以下三种状态：\n```\n    1. Pending(进行中)\n    2. Fulfilled(已成功)\n    3. Rejected(已失败)\n```","tags":["JavaScript"]},{"title":"我的开山之作","url":"/2019/01/16/我的开山之作/","content":"&emsp;&emsp;我的第一遍博客,什么都不说,只是想说说我的心里话,第一遍博客就先走走流水账吧,从什么时候说起呢,回忆回忆过去,展望展望未来,希望能一直走下去.不过现在的生活比以前好太多,什么都不缺,虽然烦心事一直很多,但是好在慢慢长大.<br/>\n&emsp;&emsp;回忆就要慢慢来,先从爱情开始回忆吧,丢了心,丢在一个看似很和谐,有父亲的家里,那会太小,不知道贫贱夫妻百事衰,所以坚持去找,也想去放纵自己,结果慢慢自己就老了,第一次远去.记得大学最后一年实习,抛开了一切,放弃了一切,放弃家里得管教,父母的束缚,去奔跑自己的世界,想着那么大去看看,也确实是啊,在别人那里看到了不同的生活态度,生活方式,在哪里的日子是我过得最快乐的时光.后来我终于败在现实下,其实也是败在自己的心理下,这大概也是我到现在还依旧单身的原因吧.\n&emsp;&emsp;慢慢的来到了北京,在北京认识了新的朋友,融入了新的社会交际圈,才知道我以前有多单纯,如果说以前生活的是如雪的世界,那么现在生活的地方就是黄河,不过也是该自己去成长了.\n&emsp;&emsp;明明想建一个博客装的,结果现在成了自己的私人发泄地方,所以嘛,这是唯一一次,\n不知道不满足什么,大概是父母的唠叨,大概是老了.\n\n&emsp;&emsp;好了回忆到此为止,下来就是我要发表我的个人获奖感言,下面就是我在成长道路上的坚持了.\n\n\n\n*****\n  放下过去,看向未来,我是一个女战士\n*****\n","tags":["Html"]}]